import retrofit2.Response

/**
 * @author ekremyigit
 *
 * API response class to handle nullable generic Retrofit2 Response.
 *
 * - Sealed class helps to handle all cases same class. Failure Loading Success etc.
 * - response is a A response from api that is handled from NetworkService with suspend flow function
 * - data is a nullable generic retrofit2 de-serialized response body of a successful data comes from api call.
 * - baseModel is a helper object to package common REST fields.
 */
sealed class BaseResponse<out T>(var baseModel: BaseModel) {
    data class Success<T>(val response: Response<T>): BaseResponse<T>(getDelaminatedApiResponse(response)){
        val data: T by lazy { response.body() ?: throw NotImplementedError(StatusCode.Unknown.name) }
    }

    data class Failure<T>(val response: Response<T>) : BaseResponse<T>(getDelaminatedApiResponse(response)) {
        override fun toString(): String = "[ApiResponse.Failure.Error-${baseModel.statusCode}](errorResponse=$response)"
    }

    companion object {
        fun <T> getDelaminatedApiResponse(response: Response<T>): BaseModel =
            BaseModel().apply {
                statusCode = StatusCode.values().find { it.code == response.code() }
                headers = response.headers()
                rawResponse = response.raw()
                errorBody = response.errorBody()
            }

    }
}



data class BaseModel(
    var statusCode: Constants.StatusCode? = null,
    var headers: Headers? = null,
    var rawResponse: okhttp3.Response? = null,
    var errorBody: ResponseBody? = null,
)



@Module
@InstallIn(SingletonComponent::class)
object PersistenceModule {

    @Provides
    @Singleton
    fun provideMoshiConverterFactory(): MoshiConverterFactory = MoshiConverterFactory.create()


    @Provides
    @Singleton
    fun provideHttpClient(): OkHttpClient {
        val clientBuilder = OkHttpClient.Builder()
        clientBuilder.addInterceptor { chain ->
            val requestBuilder = chain.request().newBuilder()
                .addHeader("Accept", "application/json")
                .addHeader("Content-Type", "application/json")
            val request = requestBuilder.build()
            val response = chain.proceed(request)
            response
        }
        return clientBuilder.build()
    }
}